// Generated by CoffeeScript 1.3.3

/*
@author aleeper / http://adamleeper.com/
@author mrdoob / http://mrdoob.com/
@author jaekwon / http://kopimism.org/

Description: A THREE loader for STL files, as created by Solidworks and other CAD programs.
Limitations: The binary loader could be optimized for memory.
*/


(function() {
  var THREE, Triangle, parseAscii, parseBinary;

  THREE = require('three');

  Triangle = function() {
    var _attr;
    this._sa = 0;
    this._buffer = new ArrayBuffer(50);
    this.__byte = new Uint8Array(this._buffer);
    this.normal = new Float32Array(this._buffer, this._sa + 0, 3);
    this.v1 = new Float32Array(this._buffer, this._sa + 12, 3);
    this.v2 = new Float32Array(this._buffer, this._sa + 24, 3);
    this.v3 = new Float32Array(this._buffer, this._sa + 36, 3);
    _attr = new Int16Array(this._buffer, this._sa + 48, 1);
    return Object.defineProperty(this, "attr", {
      get: function() {
        return _attr[0];
      },
      set: function(val) {
        return _attr[0] = val;
      },
      enumerable: true
    });
  };

  this.parse = function(arrayBuffer) {
    var head, u8a;
    u8a = new Uint8Array(arrayBuffer);
    head = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer, 0, 5));
    if (head === 'solid') {
      return parseAscii(u8a);
    } else {
      return parseBinary(u8a);
    }
  };

  this.parseBinary = parseBinary = function(u8a) {
    var face, geometry, i, j, len, normal, numTriangles, offset, _i, _j;
    geometry = new THREE.Geometry();
    numTriangles = u8a[80] << 0;
    numTriangles += u8a[81] << 8;
    numTriangles += u8a[82] << 16;
    numTriangles += u8a[83] << 24;
    face = new Triangle();
    offset = 84;
    for (i = _i = 0; 0 <= numTriangles ? _i < numTriangles : _i > numTriangles; i = 0 <= numTriangles ? ++_i : --_i) {
      for (j = _j = 0; _j < 50; j = ++_j) {
        face.__byte[j] = u8a[offset + j];
      }
      geometry.vertices.push(new THREE.Vector3(face.v1[0], face.v1[1], face.v1[2]));
      geometry.vertices.push(new THREE.Vector3(face.v2[0], face.v2[1], face.v2[2]));
      geometry.vertices.push(new THREE.Vector3(face.v3[0], face.v3[1], face.v3[2]));
      normal = new THREE.Vector3(face.normal[0], face.normal[1], face.normal[2]);
      len = geometry.vertices.length;
      geometry.faces.push(new THREE.Face3(len - 3, len - 2, len - 1, normal));
      offset += 50;
    }
    geometry.computeCentroids();
    geometry.computeBoundingSphere();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    return geometry;
  };

  this.parseAscii = parseAscii = function(u8a) {
    var faces, geometry, i, idx, isBlank, len, name, normal, peekWord, readNumber, readWord, skipBlank, state, _i;
    idx = 0;
    state = 'START';
    geometry = new THREE.Geometry();
    isBlank = function() {
      var _ref;
      return (_ref = String.fromCharCode(u8a[idx])) === ' ' || _ref === '\n' || _ref === '\r';
    };
    skipBlank = function() {
      var _results;
      _results = [];
      while (isBlank() && idx < u8a.length) {
        _results.push(idx++);
      }
      return _results;
    };
    readWord = function(expected) {
      var s;
      skipBlank();
      s = '';
      while (idx < u8a.length && !isBlank()) {
        s += String.fromCharCode(u8a[idx++]);
      }
      skipBlank();
      if ((expected != null) && expected !== s) {
        throw new Error("Expected to read '" + expected + "' but got '" + s + "'");
      }
      return s;
    };
    peekWord = function(expected) {
      var idx_bak, s;
      idx_bak = idx;
      s = readWord();
      idx = idx_bak;
      if (expected != null) {
        return s === expected;
      } else {
        return s;
      }
    };
    readNumber = function() {
      var n;
      n = readWord();
      return parseFloat(n);
    };
    faces = 0;
    ScanBuffer: //;

    while (idx < u8a.length) {
      switch (state) {
        case 'START':
          readWord('solid');
          name = readWord();
          state = 'FACET';
          continue;
        case 'FACET':
          faces += 1;
          if (faces % 100 === 0) {
            console.log(faces, idx);
          }
          readWord('facet');
          readWord('normal');
          normal = new THREE.Vector3(readNumber(), readNumber(), readNumber());
          readWord('outer');
          readWord('loop');
          for (i = _i = 0; _i < 3; i = ++_i) {
            readWord('vertex');
            geometry.vertices.push(new THREE.Vector3(readNumber(), readNumber(), readNumber()));
          }
          readWord('endloop');
          readWord('endfacet');
          len = geometry.vertices.length;
          geometry.faces.push(new THREE.Face3(len - 3, len - 2, len - 1, normal));
          if (peekWord('endsolid')) {
            state = 'END';
          }
          continue;
        case 'END':
          break ScanBuffer;;

          break;
        default:
          throw new Error("Unexpected state " + state);
      }
    }
    if (state !== 'END') {
      throw new Error("WTF, state should have been END but was " + state);
    }
    geometry.computeCentroids();
    geometry.computeBoundingSphere();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    return geometry;
  };

}).call(this);
